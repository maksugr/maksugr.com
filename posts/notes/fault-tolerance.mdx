---
title: 'Fault tolerance'
summary: 'Fault tolerance summary'
topics: ['fault tolerance']
publishedAt: '2022-04-25'
---

## Requirements

To be fault tolerant, [a system](/notes/system) must be able to:

* detect
* diagnose
* confine
* mask
* compensate
* recover

## Degree

The degree of fault tolerance a system requires can be specified [quantitatively](#quantitative-goals) or [qualitatively](#qualitative-goals).

### Quantitative Goals

A quantitative reliability goal is usually expressed as the maximum allowed failure-rate. For example, the reliability figure usually stated as a goal for computer systems in commercial aircraft is less than 10<sup>-9</sup> failures per hour. The problem with stating reliability requirements in this manner is that it is difficult to know when it has been achieved. Standard statistical methods cannot be used to show such reliability with either standard or fault tolerant software. It is also clear that there is no way to achieve confidence that a system meets such a reliability goal through random testing. Nevertheless, reliability goals are often expressed in this manner.

### Qualitative Goals

An alternative method of specifying a system's reliability characteristics is to specify them qualitatively. Typical specifications would include next goals.

#### Fail-safe

Design the system so that, when it sustains a specified number of faults, it fails in a safe mode. For instance, railway signalling systems are designed to fail so that all trains stop.

#### Fail-op

Design the system so that, when it sustains a specified number of faults, it still provides a subset of its specified behavior.

#### No single point of failure

Design the system so that the failure of any single component will not cause the system to fail. Such systems are often designed so that the failed component can be replaced or repaired before another failure occurs.

#### Consistency

Design the system so that all information delivered by the system is equivalent to the information that would be delivered by an instance of a non-faulty system.

## Levels

There are three levels at which fault tolerance can be applied:

- [Hardware](#hardware-fault-tolerance)
- [Software](#software-fault-tolerance)
- [System](#system-fault-tolerance)

### Hardware fault tolerance

Traditionally, fault tolerance has been used to compensate for faults in computing resources. By managing extra hardware resources, the computer subsystem increases its ability to continue operation. Hardware fault tolerance measures include:

* redundant communications
* replicated processors
* additional memory
* redundant power/energy supplies.

Hardware fault tolerance was particularly important in the early days of computing when the time between machine failures was measured in minutes.

### Software fault tolerance

The second level of fault tolerance recognizes that a fault-tolerant hardware platform does not, in itself, guarantee high availability to the system user. It is still important to structure the computer software to compensate for faults such as changes in programs or data structures due to transients or design errors. This is software fault tolerance. Mechanisms such as:

* [checkpoint](#checkpoint)
* [restart](#restart)
* [recovery blocks](#recovery-blocks)
* [multiple-version programs](#multiple-version-programs)

are often used at this level.

#### Checkpoint

#### Restart

#### Recovery blocks

#### Multiple-version programs

### System fault tolerance

At a third level, the computer subsystem may provide functions that compensate for failures in other system facilities that are not computer-based. This is system fault tolerance. For example, software can detect and compensate for failures in sensors. Measures at this level are usually application-specific. It is important that fault tolerance measures at all levels be compatible.

---

#### References

* Walter L. Heimerdinger, Charles B. Weinstock, "A Conceptual Framework for System Fault Tolerance";
